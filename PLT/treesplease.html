<meta charset="utf-8">

<script src="js/jquery.js"></script>
<script src="js/jqconsole.js"></script>
<script src="js/sugar.js"></script>
<script src="js/peg.js"></script>
<script src="js/plt.js"></script>

<script type="text/javascript">
  // uncomment next line to enable refresh
  // PLT.refresh = true

  var dict = {
    '+': infix,
    '-': infix,
    '*': infix,
    '<': infix,
    '>': infix,
    '=': comparison,
    'print': print,
    'if': conditional,
    'let': let,
    'assignment': assignment
  };

  var vars = { }; // to hold any vars declared with let

  function moveOverArgs(currentArr, arr) {
    typeof arr[0] === 'object' ? currentArr.push(evaluate(arr[0])) : currentArr.push(arr[0]);
    
    var remainingArr = arr.slice(1);
    if (remainingArr.length > 0) { 
      return moveOverArgs(currentArr, remainingArr);
    } else {
      return currentArr;
    }
  }

  function moveOverAssignment(currentArr, arr){

    var expression = arr[0];
    expression = replaceVars(expression, Object.keys(vars));
    currentArr.push(evaluate(PLT.parser.parse(expression)));

    var remainingArr = arr.slice(1);
    if (remainingArr.length > 0){
      return moveOverAssignment(currentArr, remainingArr);
    } else {
      return currentArr.join(", ");
    }
  }

  function replaceVars(expression, keys){

    var key = keys[0];
    expression = expression.replace(key, '"' + vars[key] + '"');

    var remainingKeys = keys.slice(1);
    if (remainingKeys.length > 0){
      return replaceVars(expression, remainingKeys);
    } else {
      return expression;
    }
  }

  function unpackAssignment(assignmentArr){
    for (var i=0; i < assignmentArr.length; i++){
      assignment(assignmentArr[i].left, assignmentArr[i].right);
    }
    return true;
  }

  function infix(operator, args) {
    args = moveOverArgs([], args);
    return eval(args.join(operator));
  };

  function comparison(operator, args) {
    args = moveOverArgs([], args);
    return eval(args.join('==='));
  };

  function print(operator, args) {
    return ''+ args.slice(0, -1); // remove comma
  };

  function conditional(operator, args) { 
    if (args[0]){
      return evaluate(args[1]);
    } else {
      return evaluate(args[2]);
    }
  }

  function let(operator, args) {
    return moveOverAssignment([], args.slice(1)); // first arg from let returns true 
  }

  function assignment(a, b) {
    vars[a] = b;
  }

  var evaluate = function(ast) {

    var unpacked = (function unpack(left, right) {

      left instanceof Array && (left = unpackAssignment(left));
      typeof left === 'object' && (left = evaluate(left));
      
      var args = [];
      args.push(left);
      return args.concat(right);

    })(ast.left, ast.right);

    return dict[ast.operator](ast.operator, unpacked);

  };

   /*
   * run code
   * this takes as input a javascript string representing code in your laguage,
   * parses it using the grammar you provided to the PLT framework, then acts
   * on it using the functions above. 
   */
  
  var run = function(source) {
    var ast = PLT.parser.parse(source);
    return evaluate(ast);
  };
  
  // connect the REPL prompt in the browser to your language's run function
  PLT.repl = run;

</script>

<title>Language</title>

<grammar>
  start             = program / id
  program           = scope / assignment / operation / string / number

  scope             = space '(' space 'let' space as:assignment+ space ar:args* space ')'
                      {return { operator: 'let', left: as, right: ar  } }
  args              = space '(' n:[^()]+ ')' space {return '(' + n.join("") + ')'}


  operation         = space '(' space o:operator space lh:start space rh:program* space ')' space 
                      { return {operator: o, 'left': lh, right: rh.length ? rh : undefined }}
  operator          = '>'/'<'/'+'/'-'/'*'/'='/'if'/'let'/'print'/id


  string            = quote str:(mandatory_space/letter)+ quote { return str.join("") ; }
  assignment        = space '[' space i:id space s:string space ']' space 
                      { return { operator: 'assignment', left:i, right: s }; }

  id                = t:text+ { return t.join(""); }
  letter            = [^" \n]
  text              = [a-zA-Z-]

  number            = d:digit+ space { return +(d.join(''));  }
  digit             = [0123456789.-]

  space             = [ \n]* / !. { return undefined }
  mandatory_space   = [ \n]+ / !. { return undefined }

  quote             = ["']

</grammar>

<h3>Numbers</h3>
<code>67</code>
<code>-17</code>
<code>22.3</code>
<code>-0.3</code>

<h3>Strings</h3>
<code>"Hello, World!"</code>

<h3>Identifiers</h3>
<em>These are used for variable names. How do you parse them into somehting different from a string?</em>
<code>foo</code>
<code>bar</code>
<code>some-identifier</code>

<h3>Operations</h3>
<code>(+ 1 2)</code>
<code>(- 1 2)</code>
<code>(* 1 2)</code>
<code>(+ 1 2 3 4 5)</code>
<code>(< 5 6)</code>
<code>(< 5 6 8 20 34)</code>
<code>(+ 5 6 (+ 8 20) 34)</code>
<code>(print "Hello, World!")</code>
<code>(= (+ 1 2) (+ 3 4))</code>

<h3>Nesting</h3>
<code>(< (+ 1 2) 6)</code>
<code>(< (+ 1 2) (+ 8 (* 3 (+ 8 (* 3 (+ 8 (* 3 4)))))))</code>
<code>(if (< 20 10) 55 22)</code>
<code>(if (< 20 10) (print "less!") (print "more!"))</code>
<code>(let [name "SFPC"] (print name) (print "pie"))</code>
<code>(let [name "SFPC"] [tiger "elephant"] (print name) (print "pie") (print tiger))</code>