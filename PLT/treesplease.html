<meta charset="utf-8">

<script src="js/jquery.js"></script>
<script src="js/jqconsole.js"></script>
<script src="js/sugar.js"></script>
<script src="js/peg.js"></script>
<script src="js/plt.js"></script>

<script type="text/javascript">
  // uncomment next line to enable refresh
  // PLT.refresh = true

  var dict = {
    '+': infix,
    '-': infix,
    '*': infix,
    '<': infix,
    '>': infix,
    '=': comparison,
    'print': print,
    'if': conditional,
    'let': let,
    'assignment': assignment
  };

  var vars = { }; // to hold any vars declared with let

  function moveOverArgs(currentArr, arr) {
    typeof arr[0] === 'object' ? currentArr.push(evaluate(arr[0])) : currentArr.push(arr[0]);
    
    var remainingArr = arr.slice(1);
    
    if (remainingArr.length > 0) { 
      return moveOverArgs(currentArr, remainingArr);
    } else {
      return currentArr;
    }

  };

  function moveOverAssignment(currentArr, arr){

    // for each item in the array, replace any instance of any vars, 

    console.log(arr);
    var testBuddy = arr[0],
        keys = Object.keys(vars),
        testKey, testValue;
        
        for (var i=0, l=keys.length; i < l; i++){
          testKey = keys[i];
          // console.log("TK: ", testKey);
          testValue = vars[testKey];
          // console.log("TV: " + testValue);
          // console.log("TestBuddy:", testBuddy);
          testBuddy = testBuddy.replace(testKey, '"' + testValue + '"');
          // console.log(testBuddy);
        }
    // console.log(testBuddy);
 
    var ast = PLT.parser.parse(testBuddy);
    return evaluate(ast);

  }

  function replaceVars(){

  }

  function infix(operator, args) {
    args = moveOverArgs([], args);
    return eval(args.join(operator));
  };

  function comparison(operator, args) {
    args = moveOverArgs([], args);
    return eval(args.join('==='));
  };

  function print(operator, args) {
    return ''+ args.slice(0, -1); // remove comma
  };

  function conditional(operator, args) { 
    if (args[0]){
      return evaluate(args[1]);
    } else {
      return evaluate(args[2]);
    }
  };

  function let(operator, args) {
    // console.log(operator, args);
    return moveOverAssignment([], args.slice(1)); // first arg from let returns undefined 
    // return evaluate(args); // TODO: evaluate all args
  };

  function assignment(operator, args) {
    vars[args[0]] = args[1];
    // console.log(vars[args[0]]);
  };



  var evaluate = function(ast) {

    var unpacked = (function unpack(left, right) {

      typeof left === 'object' && (left = evaluate(left));
      
      var args = [];
      args.push(left);
      return args.concat(right);

    })(ast.left, ast.right);

    return dict[ast.operator](ast.operator, unpacked);

  };

   /*
   * run code
   * this takes as input a javascript string representing code in your laguage,
   * parses it using the grammar you provided to the PLT framework, then acts
   * on it using the functions above. 
   */
  
  var run = function(source) {
    var ast = PLT.parser.parse(source);
    return evaluate(ast);
  };
  
  // connect the REPL prompt in the browser to your language's run function
  PLT.repl = run;

</script>

<title>Language</title>

<grammar>
  start             = program / id
  program           = scope / operation / string / number

  scope             = space '(' space 'let' space '(' space i:id space a:string space ')' space ar:args* space ')'
                      {return { operator: 'let', left: { operator: 'assignment', left: i.left, right: a }, right: ar  } }
  args              = space '(' n:[^()]+ ')' space {return '(' + n.join("") + ')'}


  operation         = space '(' space o:operator space lh:start space rh:program* space ')' space 
                      { return {operator: o, 'left': lh, right: rh.length ? rh : undefined }}
  operator          = '>'/'<'/'+'/'-'/'*'/'='/'if'/'let'/'print'/id


  string            = quote str:(mandatory_space/letter)+ quote { return str.join("") ; }
  id                = t:text+ { return {operator: 'assignment', left: t.join("") } ; }
  letter            = [^" \n]
  text              = [a-zA-Z-]

  number            = d:digit+ space { return +(d.join(''));  }
  digit             = [0123456789.-]

  space             = [ \n]* / !. { return undefined }
  mandatory_space   = [ \n]+ / !. { return undefined }

  quote             = ["']

</grammar>

<h3>Numbers</h3>
<code>67</code>
<code>-17</code>
<code>22.3</code>
<code>-0.3</code>

<h3>Strings</h3>
<code>"Hello, World!"</code>

<h3>Identifiers</h3>
<em>These are used for variable names. How do you parse them into somehting different from a string?</em>
<code>foo</code>
<code>bar</code>
<code>some-identifier</code>

<h3>Operations</h3>
<code>(+ 1 2)</code>
<code>(- 1 2)</code>
<code>(* 1 2)</code>
<code>(+ 1 2 3 4 5)</code>
<code>(< 5 6)</code>
<code>(< 5 6 8 20 34)</code>
<code>(+ 5 6 (+ 8 20) 34)</code>
<code>(print "Hello, World!")</code>
<code>(= (+ 1 2) (+ 3 4))</code>

<h3>Nesting</h3>
<code>(< (+ 1 2) 6)</code>
<code>(< (+ 1 2) (+ 8 (* 3 (+ 8 (* 3 (+ 8 (* 3 4)))))))</code>
<code>(if (< 20 10) 55 22)</code>
<code>(if (< 20 10) (print "less!") (print "more!"))</code>
<code>(let (name "SFPC") (print name) (print "pie"))</code>