<meta charset="utf-8">

<script src="js/jquery.js"></script>
<script src="js/jqconsole.js"></script>
<script src="js/sugar.js"></script>
<script src="js/peg.js"></script>
<script src="js/plt.js"></script>

<script type="text/javascript">
  // uncomment next line to enable refresh
  // PLT.refresh = true

  var dict = {
    '+': infix,
    '-': infix,
    '*': infix,
    '<': infix,
    '>': infix
  };

  function infix(operator, args) {
    return eval(args.join(operator));
  };

  var evaluate = function(ast){

    function moveOverRight(currentArr, arr){
      typeof arr[0] === 'object' ? currentArr.push(evaluate(arr[0])) : currentArr.push(arr[0]);
      
      var remainingArr = arr.slice(1);
      
      if (remainingArr.length > 0) { 
        return moveOverRight(currentArr, remainingArr);
      } else {
        return currentArr;
      }

    };

    var unpacked = (function unpack(left, right){

      typeof left === 'object' && (left = evaluate(left));
      right = moveOverRight([], right);
      
      var args = [];
      args.push(left);
      return args.concat(right);

    })(ast.left, ast.right);

    return dict[ast.operator](ast.operator, unpacked);



  };

   /*
   * run code
   * this takes as input a javascript string representing code in your laguage,
   * parses it using the grammar you provided to the PLT framework, then acts
   * on it using the functions above. 
   */
  
  var run = function(source) {
    var ast = PLT.parser.parse(source);
    return evaluate(ast);
  };
  
  // connect the REPL prompt in the browser to your language's run function
  PLT.repl = run;

</script>

<title>Language</title>

<grammar>
  start             = program / id
  program           = scope / operation / string / number

  scope             = space '(' space 'let' space '(' space i:id space a:string space ')' space ar:args+ space ')'
                      {return { let: i, val: a, args: ar  } }
  args              = '(' n:[^()]+ ')' {return '(' + n.join("") + ')'}


  operation         = space '(' space o:operator space lh:program space rh:program* space ')' space 
                      { return {operator: o, 'left': lh, right: rh.length ? rh : undefined }}
  operator          = '>'/'<'/'+'/'-'/'*'/'if'/'let'/'print'/id


  string            = quote str:(mandatory_space/letter)+ quote { return str.join("") ; }
  id                = l:letter+ { return { operator: 'assignment', id: l.join("") } ; }
  letter            = [^" \n]

  number            = d:digit+ space { return +(d.join(''));  }
  digit             = [0123456789.-]

  space             = [ \n]* / !. { return undefined }
  mandatory_space   = [ \n]+ / !. { return undefined }

  quote             = ["']

</grammar>

<h3>Numbers</h3>
<code>67</code>
<code>-17</code>
<code>22.3</code>
<code>-0.3</code>

<h3>Strings</h3>
<code>"Hello, World!"</code>

<h3>Identifiers</h3>
<em>These are used for variable names. How do you parse them into somehting different from a string?</em>
<code>foo</code>
<code>bar</code>
<code>some-identifier</code>

<h3>Operations</h3>
<code>(+ 1 2)</code>
<code>(- 1 2)</code>
<code>(* 1 2)</code>
<code>(+ 1 2 3 4 5)</code>
<code>(< 5 6)</code>
<code>(< 5 6 8 20 34)</code>
<code>(+ 5 6 (+ 8 20) 34)</code>
<code>(print "Hello, World!")</code>

<h3>Nesting</h3>
<code>(< (+ 1 2) 6)</code>
<code>(< (+ 1 2) (+ 8 (* 3 (+ 8 (* 3 (+ 8 (* 3 4)))))))</code>
<code>(if (< 20 10) 55 22)</code>
<code>(if (< 20 10) (print "less!") (print "more!"))</code>
<code>(let (name "SFPC") (print name)(eat pie))</code>